#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import streamlit as st
import pandas as pd
import numpy as np
import requests
import os
import altair as alt
import itertools
import warnings
import time
from collections import Counter
from typing import List, Tuple, Any, Dict
from fpdf import FPDF

# Scikit-learn
from sklearn.linear_model import LogisticRegression
from sklearn.calibration import CalibratedClassifierCV
from sklearn.model_selection import TimeSeriesSplit
from sklearn.preprocessing import StandardScaler
from sklearn.exceptions import NotFittedError

# =============================================================================
# CONFIGURA√á√ïES INICIAIS
# =============================================================================
warnings.filterwarnings("ignore")
st.set_page_config(
    layout="wide", 
    page_title="An√°lise Mega-Sena AI", 
    page_icon="üé≤",
    initial_sidebar_state="collapsed"
)

# Constantes Globais
COLUNAS_BOLAS = ['B1', 'B2', 'B3', 'B4', 'B5', 'B6']
ALL_NUMBERS = list(range(1, 61))

# =============================================================================
# 0. DESIGN SYSTEM & CSS
# =============================================================================

def inject_custom_css():
    """Injeta CSS para remover a sidebar, criar bot√µes estilizados e estilizar login."""
    st.markdown(
        f"""
        <style>
            /* 1. REMOVER SIDEBAR E ELEMENTOS PADR√ÉO */
            section[data-testid="stSidebar"] {{ display: none !important; }}
            #MainMenu {{ visibility: hidden; }}
            footer {{ visibility: hidden; }}
            
            /* 2. ESTILO GERAL (FUNDO E TEXTO) */
            .stApp {{
                background-color: #0E1117;
                color: #E0E0E0;
            }}
            
            /* LOGIN CONTAINER (PREMIUM) */
            .premium-gate {{
                background: #1F2937;
                padding: 40px;
                border-radius: 20px;
                box-shadow: 0 20px 50px rgba(0,0,0,0.5);
                border: 2px solid #00C896; /* Borda Verde Neon */
                margin-top: 20px;
                text-align: center;
            }}

            /* INPUT FIELDS (LOGIN) */
            .stTextInput > div > div > input {{
                background-color: #111827;
                color: #f8fafc;
                border: 1px solid #374151;
                border-radius: 8px;
                padding: 10px 15px;
            }}
            .stTextInput > div > div > input:focus {{
                border-color: #00C896;
                box-shadow: 0 0 10px rgba(0, 200, 150, 0.2);
            }}
            
            h1, h2, h3 {{
                font-family: 'Helvetica Neue', sans-serif;
                font-weight: 600;
            }}
            
            h1 {{ color: #00C896; border-bottom: 2px solid #00C896; padding-bottom: 10px; }}
            h2 {{ color: #00C896; margin-top: 30px; border-left: 4px solid #00C896; padding-left: 10px; }}
            h3 {{ color: #E0E0E0; font-size: 1.2rem; margin-top: 20px; }}
            p, label {{ color: #E0E0E0; }}

            /* 3. BOT√ïES DE NAVEGA√á√ÉO */
            div.stButton > button {{
                background-color: #1F2937 !important;
                color: #9CA3AF !important;
                border: 1px solid #374151 !important;
                border-radius: 12px !important;
                padding: 10px 10px !important;
                transition: all 0.3s ease !important;
                font-weight: 500 !important;
                box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1) !important;
                width: 100% !important;
                font-size: 0.9rem !important;
            }}
            
            div.stButton > button:hover {{
                background-color: #374151 !important;
                border-color: #00C896 !important;
                color: #00C896 !important;
                transform: translateY(-2px) !important;
            }}

            div.stButton > button[kind="primary"] {{
                background: linear-gradient(145deg, #1F2937, #111827) !important;
                border: 2px solid #00C896 !important;
                color: #00C896 !important;
                box-shadow: 0 0 15px rgba(0, 200, 150, 0.5) !important;
                font-weight: 700 !important;
            }}

            /* 5. CARDS DE M√âTRICAS */
            [data-testid="stMetric"] {{
                background-color: #1F2937;
                border: 1px solid #374151;
                border-radius: 15px;
                padding: 20px;
                box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            }}
            
            [data-testid="stMetric"] label {{ color: #9CA3AF !important; }}
            [data-testid="stMetric"] div[data-testid="stMetricValue"] {{ color: #00C896 !important; font-weight: bold; }}

            /* 6. BOLAS DA LOTERIA */
            .lotto-number {{
                display: inline-flex;
                align-items: center;
                justify-content: center;
                background: linear-gradient(145deg, #00C896, #008F6B);
                color: white;
                border-radius: 50%;
                width: 32px;
                height: 32px;
                font-size: 14px;
                font-weight: bold;
                margin: 2px;
                box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                border: 1px solid #ffffff30;
            }}
            
            table {{ color: #E0E0E0; border-collapse: collapse; width: 100%; }}
            th {{ background-color: #1F2937; color: #00C896; padding: 10px; border-bottom: 2px solid #374151; }}
            td {{ padding: 8px; border-bottom: 1px solid #374151; }}
        </style>
        """,
        unsafe_allow_html=True
    )

# =============================================================================
# 0.1 SISTEMA DE BLOQUEIO PREMIUM (APENAS NA P√ÅGINA AI)
# =============================================================================

def verificar_acesso_premium():
    """
    Retorna True se o usu√°rio tiver acesso.
    Se n√£o, desenha a tela de bloqueio e retorna False.
    """
    if st.session_state.get("authenticated", False):
        return True

    # Layout do Bloqueio Premium
    col1, col2, col3 = st.columns([1, 2, 1])
    
    with col2:
        st.markdown("""
        <div class="premium-gate">
            <div style="font-size: 4rem; margin-bottom: 10px;">üíé</div>
            <h2 style="border: none; margin-top: 0; font-size: 2rem;">Recurso Premium Bloqueado</h2>
            <p style="color: #9CA3AF; font-size: 1.1rem; margin-bottom: 20px;">
                A Intelig√™ncia Artificial Preditiva √© exclusiva para assinantes.<br>
                Identifique-se para liberar o gerador.
            </p>
        </div>
        """, unsafe_allow_html=True)
        
        email_input = st.text_input("Digite seu e-mail de acesso:", placeholder="seu@email.com")
        
        # Bot√£o de Verificar
        if st.button("üîì LIBERAR ACESSO PREMIUM", type="primary", use_container_width=True):
            try:
                # SEU LINK DA PLANILHA GOOGLE
                URL_PLANILHA = "https://docs.google.com/spreadsheets/d/e/2PACX-1vRkYMs1OSrOfXnNULhKfgIkOQ90gyqyO9-nqYiBZNR21g6n-QjhbDaZUYKGzoDUV0VylpygyYeiITIj/pub?gid=0&single=true&output=csv"
                
                df_usuarios = pd.read_csv(URL_PLANILHA, dtype=str)
                
                # Valida√ß√£o (Case insensitive)
                cols_lower = [c.lower().strip() for c in df_usuarios.columns]
                if 'email' not in cols_lower:
                    st.error("Erro t√©cnico: Configura√ß√£o da planilha inv√°lida.")
                    return False
                
                col_name = df_usuarios.columns[cols_lower.index('email')]
                emails_permitidos = df_usuarios[col_name].dropna().astype(str).str.strip().str.lower().tolist()
                email_usuario = email_input.strip().lower()

                if email_usuario in emails_permitidos and "@" in email_usuario:
                    st.session_state["authenticated"] = True
                    st.toast("‚úÖ Acesso Premium Confirmado!")
                    time.sleep(1)
                    st.rerun()
                else:
                    # =================================================
                    # AQUI EST√Å A L√ìGICA DO BOT√ÉO DE COMPRA AO NEGAR
                    # =================================================
                    st.error("‚ùå E-mail n√£o encontrado na base de assinantes.")
                    
                    st.markdown("---")
                    st.markdown("#### Deseja liberar seu acesso agora?")
                    
                    st.link_button(
                        label="üí≥ COMPRAR ACESSO IMEDIATO",
                        url="https://pay.cakto.com.br/ge72qyn_671529",
                        type="primary", 
                        use_container_width=True,
                        help="Clique para ir ao checkout seguro e liberar seu e-mail."
                    )
                    
            except Exception as e:
                st.error("Erro de conex√£o ao validar.")
                print(e)

    return False

# =============================================================================
# 1. FUN√á√ïES DE DADOS E PDF
# =============================================================================

@st.cache_data(ttl=3600, show_spinner="Sincronizando dados...")
def carregar_dados_caixa() -> pd.DataFrame | None:
    folder = 'dados_mega_sena'
    if not os.path.exists(folder):
        os.makedirs(folder)
    
    url = "https://servicebus2.caixa.gov.br/portaldeloterias/api/resultados/download?modalidade=Mega-Sena"
    caminho_arquivo = os.path.join(folder, 'mega_sena.xlsx')
    response = None
    
    try:
        response = requests.get(url, timeout=30)
        response.raise_for_status()
    except requests.exceptions.SSLError:
        try:
            response = requests.get(url, timeout=30, verify=False)
            response.raise_for_status()
        except Exception:
            response = None
    except Exception:
        response = None
    
    if response is not None:
        try:
            with open(caminho_arquivo, 'wb') as f:
                f.write(response.content)
        except Exception:
            pass
    
    if not os.path.exists(caminho_arquivo):
        return None
        
    try:
        df_raw = pd.read_excel(caminho_arquivo, header=None)
        linha_cabecalho = None
        for i in range(min(10, len(df_raw))):
            linha = df_raw.iloc[i].astype(str).str.lower().values
            if any('concurso' in str(cell) for cell in linha) or any('bola' in str(cell) for cell in linha):
                linha_cabecalho = i
                break
        
        if linha_cabecalho is not None:
            df = pd.read_excel(caminho_arquivo, header=linha_cabecalho)
        else:
            df = pd.read_excel(caminho, header=1)
            
        df_clean = pd.DataFrame()
        df_cols_lower = {str(col).lower().strip(): col for col in df.columns}
        
        mapping_rules = {
            'Concurso': ['concurso', 'n√∫mero', 'numero', 'n¬∞'],
            'Data': ['data', 'data sorteio', 'data do sorteio'],
            'B1': ['bola 1', 'bola 01', 'bola1'],
            'B2': ['bola 2', 'bola 02', 'bola2'],
            'B3': ['bola 3', 'bola 03', 'bola3'],
            'B4': ['bola 4', 'bola 04', 'bola4'],
            'B5': ['bola 5', 'bola 05', 'bola5'],
            'B6': ['bola 6', 'bola 06', 'bola6']
        }
        
        for target_col, patterns in mapping_rules.items():
            for pattern in patterns:
                if pattern in df_cols_lower:
                    df_clean[target_col] = df[df_cols_lower[pattern]]
                    break
        
        # Fallback
        if len(df_clean.columns) < 4 and len(df.columns) >= 8:
            df_clean['Concurso'] = df.iloc[:, 0]
            df_clean['Data'] = df.iloc[:, 1]
            df_clean['B1'] = df.iloc[:, 2]
            df_clean['B2'] = df.iloc[:, 3]
            if len(df.columns) >= 6: df_clean['B3'] = df.iloc[:, 4]
            if len(df.columns) >= 6: df_clean['B4'] = df.iloc[:, 5]
            if len(df.columns) >= 8: df_clean['B5'] = df.iloc[:, 6]
            if len(df.columns) >= 8: df_clean['B6'] = df.iloc[:, 7]
        
        colunas_minimas = ['Concurso', 'Data', 'B1', 'B2']
        if not all(col in df_clean.columns for col in colunas_minimas):
            return None
        
        df_clean['Data'] = pd.to_datetime(df_clean['Data'], errors='coerce', dayfirst=True)
        df_clean['Concurso'] = pd.to_numeric(df_clean['Concurso'], errors='coerce')
        for col in COLUNAS_BOLAS:
            if col in df_clean.columns:
                df_clean[col] = pd.to_numeric(df_clean[col], errors='coerce')
        
        df_clean = df_clean.dropna(subset=['Concurso', 'Data', 'B1', 'B2'])
        df_clean['Concurso'] = df_clean['Concurso'].astype(int)
        for col in COLUNAS_BOLAS:
            if col in df_clean.columns:
                df_clean[col] = df_clean[col].astype(int)
        
        df_clean = df_clean.sort_values('Data', ascending=True).reset_index(drop=True)
        return df_clean
        
    except Exception:
        return None

def validar_dados(df: pd.DataFrame | None) -> bool:
    if df is None or df.empty:
        return False
    return all(col in df.columns for col in ['Concurso', 'Data', 'B1', 'B2'])

def gerar_pdf_bytes(palpites):
    """Gera o arquivo PDF na mem√≥ria para download."""
    pdf = FPDF()
    pdf.add_page()
    pdf.set_font("Arial", 'B', 16)
    
    # T√≠tulo
    pdf.cell(0, 10, "MEGA-SENA - PALPITES GERADOS (machine learning)", 0, 1, 'C')
    pdf.ln(10)
    
    # Configura√ß√£o da fonte para os jogos
    pdf.set_font("Courier", '', 14)
    
    for i, p in enumerate(palpites, 1):
        # Formata os n√∫meros para ter sempre 2 d√≠gitos (ex: 05, 09)
        numeros_fmt = " - ".join([f"{n:02d}" for n in p])
        texto = f"JOGO {i:02d}:  [ {numeros_fmt} ]"
        
        # Desenha uma borda ao redor do jogo
        pdf.cell(0, 10, texto, 1, 1, 'C')
        pdf.ln(2) # Espa√ßo entre jogos
        
    # Rodap√© simples
    pdf.ln(10)
    pdf.set_font("Arial", 'I', 10)
    pdf.cell(0, 10, "Gerado por Algoritmo Preditivo - Boa Sorte!", 0, 1, 'C')
    
    return pdf.output(dest='S').encode('latin-1')

# =============================================================================
# 2. FUN√á√ïES ESTAT√çSTICAS
# =============================================================================

@st.cache_data
def get_frequencia(df: pd.DataFrame) -> List[Tuple[int, int]]:
    bolas_disponiveis = [col for col in COLUNAS_BOLAS if col in df.columns]
    todos_numeros = df[bolas_disponiveis].values.flatten()
    frequencia = Counter(todos_numeros)
    for num in range(1, 61):
        frequencia.setdefault(num, 0)
    return sorted(frequencia.items(), key=lambda x: x[1], reverse=True)

@st.cache_data
def get_pares_impares(df: pd.DataFrame) -> pd.Series:
    bolas_disponiveis = [col for col in COLUNAS_BOLAS if col in df.columns]
    impares_matrix = df[bolas_disponiveis] % 2 == 1
    qtd_impares = impares_matrix.sum(axis=1)
    return qtd_impares.value_counts(normalize=True).sort_index() * 100

@st.cache_data
def get_frequencia_faixas(df: pd.DataFrame) -> pd.Series:
    bolas_disponiveis = [col for col in COLUNAS_BOLAS if col in df.columns]
    todos_numeros_flat = df[bolas_disponiveis].values.flatten()
    faixas_bins = [0, 10, 20, 30, 40, 50, 60]
    labels_faixas = ['1-10', '11-20', '21-30', '31-40', '41-50', '51-60']
    freq_faixas = pd.cut(todos_numeros_flat, bins=faixas_bins, labels=labels_faixas).value_counts().sort_index()
    return freq_faixas

@st.cache_data
def get_atrasados(df: pd.DataFrame) -> List[Tuple[int, int]]:
    if df.empty: return []
    bolas_disponiveis = [col for col in COLUNAS_BOLAS if col in df.columns]
    df_melted = df.melt(id_vars=['Concurso'], value_vars=bolas_disponiveis, value_name='Numero')
    ultima_aparicao = df_melted.groupby('Numero')['Concurso'].max()
    ultimo_concurso = df['Concurso'].max()
    atrasos = {}
    for num in range(1, 61):
        if num in ultima_aparicao:
            atrasos[num] = ultimo_concurso - ultima_aparicao[num]
        else:
            atrasos[num] = ultimo_concurso
    return sorted(atrasos.items(), key=lambda x: x[1], reverse=True)

@st.cache_data
def get_quentes_frios(df: pd.DataFrame, window: int = 50) -> Tuple[List, List]:
    if len(df) < window: window = len(df)
    bolas_disponiveis = [col for col in COLUNAS_BOLAS if col in df.columns]
    ultimos_sorteios = df.tail(window)
    numeros_recentes = ultimos_sorteios[bolas_disponiveis].values.flatten()
    freq_recentes = Counter(numeros_recentes)
    for num in range(1, 61): freq_recentes.setdefault(num, 0)
    freq_ordenada = freq_recentes.most_common()
    return freq_ordenada[:20], freq_ordenada[-20:][::-1]

@st.cache_data
def get_combinacoes(df: pd.DataFrame) -> Tuple[List, List]:
    bolas_disponiveis = [col for col in COLUNAS_BOLAS if col in df.columns]
    todas_duplas = Counter()
    todas_triplas = Counter()
    for _, linha in df.iterrows():
        numeros = sorted([n for n in linha[bolas_disponiveis].values if pd.notna(n)])
        for dupla in itertools.combinations(numeros, 2): todas_duplas[dupla] += 1
        for tripla in itertools.combinations(numeros, 3): todas_triplas[tripla] += 1
    return todas_duplas.most_common(30), todas_triplas.most_common(30)

@st.cache_data
def get_vizinhos(df: pd.DataFrame, num_analisar: int) -> List[Tuple[int, int]]:
    bolas_disponiveis = [col for col in COLUNAS_BOLAS if col in df.columns]
    vizinhos = Counter()
    for _, linha in df.iterrows():
        numeros = [n for n in linha[bolas_disponiveis].values if pd.notna(n)]
        if num_analisar in numeros:
            for outro_num in numeros:
                if num_analisar != outro_num: vizinhos[outro_num] += 1
    return vizinhos.most_common(10)

# =============================================================================
# 3. FUN√á√ïES ML
# =============================================================================

def compute_basic_freqs_fast(df_ml, window=None):
    bolas = [c for c in COLUNAS_BOLAS if c in df_ml.columns]
    dados = df_ml.tail(window)[bolas].values.flatten() if window else df_ml[bolas].values.flatten()
    freq = pd.Series(dados).value_counts()
    return {n: freq.get(n, 0) for n in ALL_NUMBERS}

def exponential_moving_freq_fast(df_ml, span=20):
    bolas = [c for c in COLUNAS_BOLAS if c in df_ml.columns]
    data_list = []
    for _, row in df_ml.iterrows():
        row_dict = {i: 0 for i in ALL_NUMBERS}
        for n in row[bolas].values:
            if pd.notna(n): row_dict[int(n)] = 1
        data_list.append(row_dict)
    if not data_list: return {n: 0.0 for n in ALL_NUMBERS}
    df_ohe = pd.DataFrame(data_list)
    ema = df_ohe.ewm(span=span, adjust=False).mean().iloc[-1]
    return {n: float(ema.get(n, 0.0)) for n in ALL_NUMBERS}

def last_appearance_distance_fast(df_ml, max_dist=1000):
    bolas = [c for c in COLUNAS_BOLAS if c in df_ml.columns]
    melted = []
    for col in bolas:
        for idx, val in df_ml[col].items():
            if pd.notna(val): melted.append({'index': idx, 'numero': int(val)})
    if not melted: return {n: max_dist for n in ALL_NUMBERS}
    df_m = pd.DataFrame(melted)
    last = df_m.groupby('numero')['index'].max()
    curr = df_ml.index.max()
    curr = curr + 1 if pd.notna(curr) else max_dist
    return {n: int(curr - last.get(n, -1)) if n in last else int(curr) for n in ALL_NUMBERS}

def build_features_table_fast(df_ml):
    if len(df_ml) == 0: return pd.DataFrame()
    min_len = len(df_ml)
    f_all = compute_basic_freqs_fast(df_ml)
    f_50 = compute_basic_freqs_fast(df_ml, 50)
    f_10 = compute_basic_freqs_fast(df_ml, 10)
    ema_20 = exponential_moving_freq_fast(df_ml, 20) if min_len >= 10 else {n:0.0 for n in ALL_NUMBERS}
    ema_50 = exponential_moving_freq_fast(df_ml, 50) if min_len >= 10 else {n:0.0 for n in ALL_NUMBERS}
    ldist = last_appearance_distance_fast(df_ml, min_len + 100)
    
    data = []
    for n in ALL_NUMBERS:
        data.append({
            'numero': n, 'freq_all': f_all.get(n,0), 'freq_50': f_50.get(n,0), 'freq_10': f_10.get(n,0),
            'ema_20': ema_20.get(n,0.0), 'ema_50': ema_50.get(n,0.0), 'last_dist': ldist.get(n, min_len),
            'is_even': n%2, 'is_leq30': 1 if n<=30 else 0, 'decena': (n-1)//10, 'is_mult_5': 1 if n%5==0 else 0
        })
    feat = pd.DataFrame(data).set_index('numero')
    for c in ['freq_all','freq_50','freq_10']: feat[f'{c}_norm'] = feat[c]/max(1, feat[c].max())
    feat['last_dist_norm'] = feat['last_dist']/max(1, feat['last_dist'].max())
    return feat[['freq_all_norm','freq_50_norm','freq_10_norm','ema_20','ema_50','last_dist_norm','is_even','is_leq30','decena','is_mult_5']]

def create_training_dataset_fast(df_ml, sample_fraction=0.3):
    df_sorted = df_ml.reset_index(drop=True)
    n = len(df_sorted)
    start_idx = max(50, int(0.15 * n))
    time_points = list(range(start_idx, n-1))
    if len(time_points) > 100: time_points = time_points[::max(1, len(time_points)//100)]
    
    examples, targets = [], []
    bolas = [c for c in COLUNAS_BOLAS if c in df_sorted.columns]
    
    prog = st.progress(0, text="Processando dados...")
    for i, t in enumerate(time_points):
        prog.progress((i+1)/len(time_points), text=f"Analisando per√≠odo {t}/{n}")
        df_until = df_sorted.iloc[:t+1]
        feats = build_features_table_fast(df_until)
        prox = set(df_sorted.loc[t+1, bolas].tolist())
        
        amostra = list(ALL_NUMBERS)
        if sample_fraction < 1.0:
            n_samp = max(15, int(60 * sample_fraction))
            prox_list = list(prox)
            nao_sort = [x for x in ALL_NUMBERS if x not in prox]
            n_rest = max(0, n_samp - len(prox_list))
            sub = np.random.choice(nao_sort, n_rest, replace=False).tolist()
            amostra = prox_list + sub
            
        for num in amostra:
            examples.append(feats.loc[num].values)
            targets.append(1 if num in prox else 0)
    prog.empty()
    return (np.array(examples) if examples else np.empty((0,0))), np.array(targets, dtype=int), df_sorted

@st.cache_resource(ttl=3600)
def treinar_modelo_avancado(df, use_sampling=True):
    if len(df) < 80: raise ValueError("Dados insuficientes.")
    frac = 0.4 if use_sampling and len(df) > 500 else 0.8
    with st.spinner("Preparando IA (pode demorar um pouco)..."):
        X, y, df_s = create_training_dataset_fast(df, frac)
    if len(X) == 0: raise ValueError("Erro ao gerar features.")
    
    scaler = StandardScaler()
    X_sc = scaler.fit_transform(X)
    
    base = LogisticRegression(max_iter=500, class_weight='balanced', solver='lbfgs', C=0.1, random_state=42)
    splits = max(2, min(3, len(X_sc)//3000))
    cv = TimeSeriesSplit(n_splits=splits) if len(X_sc) >= 500 else 3
    
    calib = CalibratedClassifierCV(estimator=base, cv=cv, method='sigmoid', n_jobs=-1)
    calib.fit(X_sc, y)
    return calib, scaler, df_s

def gerar_previsoes_avancadas(df_s, model, scaler):
    feats = build_features_table_fast(df_s)
    X_sc = scaler.transform(feats.values)
    probs = model.predict_proba(X_sc)[:, 1]
    exps = np.exp(probs - np.max(probs))
    rel = exps / exps.sum()
    return sorted([(int(n), float(rel[i])) for i, n in enumerate(feats.index)], key=lambda x: x[1], reverse=True)

def safe_weighted_choice(population, weights, k):
    try:
        w = np.maximum(np.array(weights, dtype=float), 0)
        if w.sum() == 0: w = np.ones_like(w)
        p = w / w.sum()
        return [population[i] for i in np.random.choice(len(population), size=k, replace=False, p=p)]
    except:
        return list(np.random.choice(population, size=k, replace=False))

@st.cache_data
def gerar_combinacoes_avancadas(preds, n_comb=8, div=True):
    nums, pes = [p[0] for p in preds], [p[1] for p in preds]
    cands, p_cands = nums[:30], pes[:30]
    combs = set()
    att = 0
    while len(combs) < n_comb and att < 100:
        att += 1
        c = safe_weighted_choice(cands, p_cands, 6)
        if div:
            par = sum(1 for x in c if x % 2 == 0)
            if par < 2 or par > 4: continue
        combs.add(tuple(sorted(c)))
    return [list(c) for c in list(combs)[:n_comb]]

# =============================================================================
# 4. INTERFACE E NAVEGA√á√ÉO
# =============================================================================

def draw_navigation():
    """Barra de navega√ß√£o superior responsiva."""
    pages = {
        "Vis√£o Geral": "üìä",
        "Frequ√™ncia": "üìà",
        "Pares/Impares": "‚öñÔ∏è",
        "Combina√ß√µes": "ü§ù",
        "Quentes/Frios": "üî•",
        "‚àë Somas": "‚ûï",
        "Previs√µes AI": "ü§ñ"
    }
    
    if 'current_page' not in st.session_state:
        st.session_state['current_page'] = "Vis√£o Geral"

    cols = st.columns(len(pages))
    
    for col, (page_name, icon) in zip(cols, pages.items()):
        # O bot√£o da p√°gina atual recebe 'primary' para ativar o CSS de brilho
        btn_type = "primary" if st.session_state['current_page'] == page_name else "secondary"
        
        label = f"{icon}\n{page_name}"
        if col.button(label, key=f"nav_{page_name}", use_container_width=True, type=btn_type):
            st.session_state['current_page'] = page_name
            st.rerun()
            
    st.markdown("---")

# =============================================================================
# 5. P√ÅGINAS DE CONTE√öDO
# =============================================================================

def page_visao_geral(df):
    st.header("üìä Vis√£o Geral dos Sorteios")
    
    col1, col2, col3 = st.columns(3)
    col1.metric("Total Sorteios", f"{len(df):,}")
    col2.metric("√öltimo Concurso", f"{df['Concurso'].iloc[-1]}")
    col3.metric("Data Recente", df['Data'].iloc[-1].strftime('%d/%m/%Y'))
    
    st.divider()
    
    st.subheader("√öltimos 20 Resultados")
    df_recent = df.tail(20).sort_values('Data', ascending=False)
    
    html_table = "<table><thead><tr><th>Concurso</th><th>Data</th><th>N√∫meros Sorteados</th></tr></thead><tbody>"
    
    for _, row in df_recent.iterrows():
        bolas_html = "".join([f'<span class="lotto-number">{int(row[col])}</span>' for col in COLUNAS_BOLAS if pd.notna(row[col])])
        data_fmt = row['Data'].strftime('%d/%m/%Y')
        html_table += f"<tr><td>{row['Concurso']}</td><td>{data_fmt}</td><td>{bolas_html}</td></tr>"
    
    html_table += "</tbody></table>"
    st.markdown(html_table, unsafe_allow_html=True)
    
    st.divider()
    
    st.subheader("Hist√≥rico Temporal")
    df_ano = df.copy()
    df_ano['Ano'] = df_ano['Data'].dt.year
    chart = alt.Chart(df_ano.groupby('Ano').size().reset_index(name='Qtd')).mark_bar(color='#00C896').encode(
        x='Ano:O', y='Qtd:Q', tooltip=['Ano','Qtd']
    ).properties(height=300).interactive()
    st.altair_chart(chart, use_container_width=True)

def page_frequencia(df):
    st.header("üìà Frequ√™ncia dos N√∫meros")
    st.markdown("Contagem total de vezes que cada n√∫mero foi sorteado.")
    
    freq_data = get_frequencia(df)
    df_freq = pd.DataFrame(freq_data, columns=['N√∫mero', 'Frequ√™ncia'])
    
    chart = alt.Chart(df_freq).mark_bar(color='#00C896').encode(
        x=alt.X('N√∫mero:O', sort='-y', title='N√∫mero (1 a 60)'), 
        y=alt.Y('Frequ√™ncia:Q', title='Frequ√™ncia'),
        tooltip=['N√∫mero', 'Frequ√™ncia']
    ).interactive()
    st.altair_chart(chart, use_container_width=True)
    
    st.divider()
    
    c1, c2 = st.columns(2)
    with c1:
        st.subheader("üî• Top 15 Mais Frequentes")
        st.dataframe(df_freq.head(15), use_container_width=True, hide_index=True)
    
    with c2:
        st.subheader("‚ùÑÔ∏è Top 15 Menos Frequentes")
        st.dataframe(df_freq.tail(15).sort_values('Frequ√™ncia'), use_container_width=True, hide_index=True)

def page_pares_impares(df):
    st.header("‚öñÔ∏è Pares, √çmpares e Faixas")
    
    par_impar = get_pares_impares(df).reset_index(name='Perc')
    par_impar.columns = ['Qtd_Impares', 'Percentual']
    par_impar['Label'] = par_impar['Qtd_Impares'].apply(lambda x: f"{x} √çmpares / {6-x} Pares")
    
    faixas = get_frequencia_faixas(df).reset_index(name='Freq')
    faixas.columns = ['Faixa', 'Frequ√™ncia']
    faixas['Percentual'] = (faixas['Frequ√™ncia'] / faixas['Frequ√™ncia'].sum() * 100).round(1)
    
    c1, c2 = st.columns(2)
    
    with c1:
        st.subheader("Distribui√ß√£o Par/√çmpar")
        pie = alt.Chart(par_impar).mark_arc(innerRadius=60).encode(
            theta=alt.Theta("Percentual", stack=True),
            color=alt.Color("Label", legend=alt.Legend(title="Combina√ß√£o")), 
            tooltip=["Label", alt.Tooltip("Percentual", format='.1f')]
        )
        st.altair_chart(pie, use_container_width=True)
        
    with c2:
        st.subheader("Frequ√™ncia por Faixas")
        bar = alt.Chart(faixas).mark_bar(color='#2E8B57').encode(
            x=alt.X('Faixa', title='Faixa (Dezena)'), 
            y='Frequ√™ncia', 
            tooltip=['Faixa','Frequ√™ncia', 'Percentual']
        )
        st.altair_chart(bar, use_container_width=True)
        
    st.divider()
    st.subheader("Detalhamento por Faixas")
    st.dataframe(faixas, use_container_width=True, hide_index=True)

def page_combinacoes(df):
    st.header("ü§ù An√°lise de Combina√ß√µes")
    tipo = st.radio("Escolha o foco da an√°lise:", ["Duplas Mais Frequentes", "Triplas Mais Frequentes", "N√∫meros Vizinhos"], horizontal=True)
    
    st.divider()
    
    if tipo == "N√∫meros Vizinhos":
        col_sel, col_info = st.columns([1,2])
        with col_sel:
            num = st.selectbox("Selecione o n√∫mero piv√¥:", ALL_NUMBERS, index=9)
        
        viz = pd.DataFrame(get_vizinhos(df, num), columns=['Vizinho', 'Frequ√™ncia Conjunta'])
        
        with col_info:
            st.info(f"Mostrando n√∫meros que mais saem com o **{num}**.")
            st.altair_chart(alt.Chart(viz).mark_bar(color='#00C896').encode(
                x='Frequ√™ncia Conjunta', y=alt.Y('Vizinho:O', sort='-x'), tooltip=['Vizinho','Frequ√™ncia Conjunta']
            ), use_container_width=True)
            
        st.dataframe(viz, use_container_width=True, hide_index=True)
        
    else:
        duplas, triplas = get_combinacoes(df)
        if tipo == "Duplas Mais Frequentes":
            st.subheader("üèÜ Top 20 Duplas")
            df_c = pd.DataFrame(duplas[:20], columns=['Dupla', 'Frequ√™ncia'])
            df_c['Dupla'] = df_c['Dupla'].apply(lambda x: f"{x[0]} e {x[1]}")
            st.dataframe(df_c, use_container_width=True, hide_index=True)
        else:
            st.subheader("üèÜ Top 20 Triplas")
            df_c = pd.DataFrame(triplas[:20], columns=['Tripla', 'Frequ√™ncia'])
            df_c['Tripla'] = df_c['Tripla'].apply(lambda x: f"{x[0]}, {x[1]} e {x[2]}")
            st.dataframe(df_c, use_container_width=True, hide_index=True)

def page_quentes(df):
    st.header("üî•‚ùÑÔ∏è Quentes, Frios e Atrasados")
    
    win = st.slider("Janela de An√°lise (Concursos):", 5, 200, 50)
    
    atrasados_data = get_atrasados(df)
    quentes_data, frios_data = get_quentes_frios(df, win)
    
    c1, c2, c3 = st.columns(3)
    
    with c1:
        st.subheader("üî• Quentes (Top 10)")
        df_q = pd.DataFrame(quentes_data, columns=['N√∫mero', 'Frequ√™ncia'])
        st.dataframe(df_q.head(10), use_container_width=True, hide_index=True)
        
    with c2:
        st.subheader("‚ùÑÔ∏è Frios (Top 10)")
        df_f = pd.DataFrame(frios_data, columns=['N√∫mero', 'Frequ√™ncia'])
        st.dataframe(df_f.head(10), use_container_width=True, hide_index=True)
        
    with c3:
        st.subheader("‚è∞ Atrasados (Top 10)")
        df_a = pd.DataFrame(atrasados_data[:10], columns=['N√∫mero', 'Atraso'])
        st.dataframe(df_a, use_container_width=True, hide_index=True)
        
    st.divider()
    
    st.subheader("Gr√°fico de Atrasos (Top 20)")
    df_chart_a = pd.DataFrame(atrasados_data[:20], columns=['N√∫mero', 'Atraso'])
    st.altair_chart(alt.Chart(df_chart_a).mark_bar(color='#E91E63').encode(
        x='Atraso', y=alt.Y('N√∫mero:O', sort='-x'), tooltip=['N√∫mero','Atraso']
    ), use_container_width=True)

def page_somas(df):
    st.header("‚àë An√°lise das Somas das Dezenas")
    st.markdown("A soma das 6 dezenas de cada sorteio tende a seguir uma distribui√ß√£o normal (curva de sino).")
    
    df_soma = df.copy()
    df_soma['Soma'] = df_soma[COLUNAS_BOLAS].sum(axis=1)
    
    media = df_soma['Soma'].mean()
    min_soma = df_soma['Soma'].min()
    max_soma = df_soma['Soma'].max()
    
    moda_series = df_soma['Soma'].mode()
    moda_soma = moda_series[0] if not moda_series.empty else 0
    
    c1, c2, c3, c4 = st.columns(4)
    c1.metric("M√©dia Hist√≥rica", f"{media:.1f}")
    c2.metric("Soma M√≠nima", int(min_soma))
    c3.metric("Soma M√°xima", int(max_soma))
    c4.metric("Soma Mais Comum", int(moda_soma))
    
    st.divider()
    
    chart = alt.Chart(df_soma).mark_bar(color='#00C896').encode(
        x=alt.X('Soma:Q', bin=alt.Bin(maxbins=60), title='Faixa da Soma'),
        y=alt.Y('count()', title='Frequ√™ncia de Ocorr√™ncia'),
        tooltip=['count()', alt.Tooltip('Soma', bin=True, title='Faixa')]
    ).properties(
        title='Distribui√ß√£o Normal das Somas (Curva de Sino)',
        height=400
    ).interactive()
    
    st.altair_chart(chart, use_container_width=True)
    
    st.info("üí° **Dica Estrat√©gica:** A maioria esmagadora dos resultados da Mega-Sena tem soma entre **150 e 220**. Jogos com soma muito baixa (<100) ou muito alta (>300) s√£o estatisticamente muito raros.")
    
    st.divider()
    
    st.subheader("Somas dos √öltimos 20 Sorteios")
    df_recent = df_soma.tail(20).sort_values('Concurso', ascending=False)
    
    df_display = df_recent[['Concurso', 'Data', 'Soma'] + COLUNAS_BOLAS]
    st.dataframe(df_display, use_container_width=True, hide_index=True)

def page_ai(df):
    
    # ==========================================================
    # BLOQUEIO LOCAL (APENAS PARA ESTA P√ÅGINA)
    # ==========================================================
    if not verificar_acesso_premium():
        return
    # ==========================================================
    
    st.header("ü§ñ Intelig√™ncia Artificial Preditiva")
    st.markdown("**Regress√£o Log√≠stica com Calibra√ß√£o Temporal**")
    
    c1, c2, c3 = st.columns(3)
    with c1:
        n_comb = st.slider("Combina√ß√µes:", 1, 15, 6)
        top_k = st.slider("Ranking Top:", 10, 60, 15)
    with c2:
        div = st.checkbox("Diversificar (Par/Impar)", True)
        show_all = st.checkbox("Mostrar Probabilidades Totais", False)
    with c3:
        if 'usar_amostragem' not in st.session_state: st.session_state.usar_amostragem = True
        usar_amostragem = st.checkbox("Treino R√°pido (Amostragem)", value=st.session_state.usar_amostragem, key='check_sample')
        st.caption(f"Base de Treino: {len(df)} sorteios")
        
    st.divider()
    
    aceite = st.checkbox("‚úÖ Compreendo que √© an√°lise estat√≠stica, sem garantia de acerto.")
    
    if aceite:
        if st.button("üöÄ TREINAR MODELO E GERAR PALPITES", type="primary", use_container_width=True):
            try:
                mod, scl, df_s = treinar_modelo_avancado(df, usar_amostragem)
                preds = gerar_previsoes_avancadas(df_s, mod, scl)
                
                st.success("Modelo Treinado e Calibrado com Sucesso!")
                
                st.subheader(f"üéØ Top {top_k} Probabilidades")
                df_top = pd.DataFrame(preds[:top_k], columns=['N√∫mero', 'Probabilidade'])
                df_top['Probabilidade'] = df_top['Probabilidade'].map(lambda x: f"{x*100:.3f}%")
                
                chart = alt.Chart(df_top).mark_bar(color='#E65100').encode(
                    x=alt.X('Probabilidade:O', sort='-y'), y=alt.Y('N√∫mero:O', sort='-x')
                )
                st.altair_chart(chart, use_container_width=True)
                st.dataframe(df_top, use_container_width=True, hide_index=True)
                
                st.divider()
                
                st.subheader("üí° Combina√ß√µes Sugeridas (Otimizadas)")
                combs = gerar_combinacoes_avancadas(preds, n_comb, div)
                
                if not combs:
                    st.warning("N√£o foi poss√≠vel diversificar. Tente reduzir restri√ß√µes.")
                else:
                    for i, c in enumerate(combs, 1):
                        html_balls = "".join([f'<span class="lotto-number">{n}</span>' for n in c])
                        st.markdown(f"#### Palpite {i}: {html_balls}", unsafe_allow_html=True)
                        
                        soma = sum(c)
                        pares = sum(1 for x in c if x % 2 == 0)
                        impares = 6 - pares
                        baixos = sum(1 for x in c if x <= 30)
                        altos = 6 - baixos
                        
                        m1, m2, m3, m4 = st.columns(4)
                        m1.metric("Soma", soma)
                        m2.metric("Par/√çmpar", f"{pares}/{impares}")
                        m3.metric("Baixo/Alto", f"{baixos}/{altos}")
                        m4.metric("M√©dia", f"{soma/6:.1f}")
                        st.markdown("---")
                    
                    st.subheader("üíæ Salvar Jogos")
                    
                    # Gera PDF
                    pdf_bytes = gerar_pdf_bytes(combs)
                    st.download_button(
                        label="üìÑ BAIXAR JOGOS EM PDF",
                        data=pdf_bytes,
                        file_name='palpites_megasena_.pdf',
                        mime='application/pdf',
                        type='primary',
                        use_container_width=True
                    )

                if show_all:
                    st.subheader("Probabilidades de Todos os N√∫meros")
                    df_all = pd.DataFrame(preds, columns=['N√∫mero', 'Prob'])
                    df_all['Prob'] = df_all['Prob'].mul(100)
                    st.dataframe(df_all, use_container_width=True)
                    
            except Exception as e:
                st.error(f"Erro no processamento: {str(e)}")
    else:
        st.info("Marque o aceite para habilitar o modelo preditivo.")

# =============================================================================
# MAIN
# =============================================================================

def main():
    inject_custom_css()
    
    st.title("üé≤ An√°lise Mega-Sena")
    
    # 1. Carregar
    df = carregar_dados_caixa()
    if not validar_dados(df):
        st.error("Erro cr√≠tico: Banco de dados indispon√≠vel.")
        return

    # 2. Navega√ß√£o
    draw_navigation()
    
    # 3. Roteamento
    page = st.session_state['current_page']
    
    if page == "Vis√£o Geral":
        page_visao_geral(df)
    elif page == "Frequ√™ncia":
        page_frequencia(df)
    elif page == "Pares/Impares":
        page_pares_impares(df)
    elif page == "Combina√ß√µes":
        page_combinacoes(df)
    elif page == "Quentes/Frios":
        page_quentes(df)
    elif page == "‚àë Somas":
        page_somas(df)
    elif page == "Previs√µes AI":
        page_ai(df)  # <--- BLOQUEIO AGORA EST√Å DENTRO DESTA FUN√á√ÉO

if __name__ == "__main__":
    main()



